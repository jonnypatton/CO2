import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib.dates import DateFormatter

# Function to replace NaN with the average of previous and next valid values
def fill_with_avg_before_after(series):
    # Create a copy of the Series to avoid SettingWithCopyWarning
    series = series.copy()
    for i in range(len(series)):
        if pd.isna(series[i]):  # Check if the value is NaN
            # Find the previous valid value
            prev_valid = series[:i].last_valid_index()
            # Find the next valid value
            next_valid = series[i:].first_valid_index()
            
            if prev_valid is not None and next_valid is not None:
                # Average of previous and next valid values
                series[i] = (series[prev_valid] + series[next_valid]) / 2
            elif prev_valid is not None:
                # Fill with the previous valid value
                series[i] = series[prev_valid]
            elif next_valid is not None:
                # Fill with the next valid value
                series[i] = series[next_valid]
    return series

# Reload the data
df = pd.read_csv('history (2).csv')

# Convert 'last_changed' to datetime
df['last_changed'] = pd.to_datetime(df['last_changed'], errors='coerce')

# Convert 'state' to numeric, coercing text (e.g., "unavailable", "unknown") to NaN
df['state'] = pd.to_numeric(df['state'], errors='coerce')


# Fill NaN values (e.g., "unavailable", "unknown") with the average of previous and next valid values
df['state'] = fill_with_avg_before_after(df['state'])

# Calculate the 10-point EMA
df['10_point_ema'] = df['state'].ewm(span=10, adjust=False).mean()

# Determine whether to slice the data
slice = int(input("Do you want to slice the data? (1 for Yes, 0 for No): "))

if slice == 1:
    # Ask the user for the range of data points to plot
    start_index = int(input("Enter the starting row index (e.g., 800): "))
    end_index = int(input("Enter the ending row index (e.g., 1000): "))
    
    # Slice the DataFrame based on user input
    subset_df = df.iloc[start_index:end_index + 1]  # Add 1 to include the end index
    plot_title = f'CO2 Levels (Rows {start_index} to {end_index})'
else:
    # Use the entire DataFrame
    subset_df = df
    plot_title = 'CO2 Levels (Full Dataset)'

# Dynamically adjust the plot size based on the number of data points
num_points = len(subset_df)
fig_width = min(30, max(12, num_points * 0.05))  # Cap the width at 30 inches
fig_height = 6  # Fixed height

# Create the plot with the dynamically adjusted size
plt.figure(figsize=(fig_width, fig_height))

# Light blue for CO2 levels line
sns.lineplot(data=subset_df, x='last_changed', y='state', label='CO2 Levels', color='lightblue')

# Dark blue for 10-point EMA line
sns.lineplot(data=subset_df, x='last_changed', y='10_point_ema', label='10-Point EMA', color='darkblue')

# Add hourly vertical lines
for hour in pd.date_range(start=subset_df['last_changed'].min().floor('h'), 
                          end=subset_df['last_changed'].max().ceil('h'), freq='h'):
    plt.axvline(x=hour, color='gray', linestyle='--', alpha=0.5)

# Format x-axis
plt.gca().xaxis.set_major_formatter(DateFormatter('%H:%M'))

# Set x-axis limits to remove the gap
plt.xlim(subset_df['last_changed'].min(), subset_df['last_changed'].max())

plt.title(plot_title)
plt.xlabel('Time (HH:MM)')
plt.ylabel('CO2 Level (ppm)')
plt.xticks(rotation=45)
plt.grid(True, alpha=0.3)
plt.legend()
plt.tight_layout()
plt.show()
